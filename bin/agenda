#!/usr/bin/python

import sys
from pathlib import Path
import os
import re
from itertools import filterfalse

Metadata = Path("metadata")
Motiondir = Path('.')

def meta(name):
    return Metadata / name

def get_current(err_no_current=True):
    r'''Returns current motion as Path.
    '''
    cur = meta('current')
    if cur.exists():
        return Path(cur.read_text().rstrip('\n'))
    if err_no_current:
        print("ERROR: no current file", file=sys.stderr)
        sys.exit(1)
    return None

def as_list(filename):
    path = meta(filename)
    if not path.exists(): return []
    with path.open() as f:
        return [line.rstrip('\n') for line in f]

def in_file(name, filename):
    r'''Accepts Path as name.
    '''
    return str(name) in as_list(filename)

def check_open(motion):
    if in_file(motion, 'failed'):
        print(f"{motion} already failed", file=sys.stderr)
        sys.exit(1)
    if in_file(motion, 'passed'):
        print(f"{motion} already passed", file=sys.stderr)
        sys.exit(1)

def append(motion, filename):
    r'''Accepts Path as motion.
    '''
    with meta(filename).open('at') as f:
        print(str(motion), file=f)

def read(filename):
    with Path(filename).open() as f:
        return f.read()

number_re = re.compile(r'([-.][0-9]+)')

def expand(name):
    r'''Accepts Path as name.
    '''
    def parts():
        for part in number_re.split(str(name)):
            if part:
                if part[0] in '.-':
                    yield int(part[1:])
                    yield part[0]
                else:
                    yield part
    return tuple(parts())

def motion_history(motion, failed=()):
    return [Path(motion)] + sorted(filterfalse(lambda path: str(path) in failed, 
                                               Motiondir.glob(motion + '[-.]*')),
                                   key=expand)

def cur_agenda():
    failed = frozenset(as_list('failed'))
    passed = frozenset(as_list('passed'))
    for line in meta('agenda').open():
        motion = line.rstrip('\n')
        #print("looking at motion", motion)
        if motion not in failed and motion not in passed:
            history = motion_history(motion, failed)
            yield history[-1]

def current(motion=None):
    if motion is None:
        print(str(get_current(False)))
    else:
        meta('current').write_text(motion + '\n')

def agenda():
    for motion in cur_agenda():
        print(str(motion))

def passed():
    with meta('passed').open() as f:
        print(f.read(), end='')

def failed():
    with meta('failed').open() as f:
        print(f.read(), end='')

def start(_no_edit, motion):
    print("start", _no_edit, motion)
    motion_path = Path(motion)
    meta('current').write_text(str(motion).rstrip('\n') + '\n')
    motion_path.touch()
    if not _no_edit:
        editor = Path(os.environ['EDITOR'])
        os.execl(editor, editor.name, motion_path)

def restart(_no_edit):
    cur = get_current()
    print("restart", repr(str(cur)))
    start(_no_edit, cur)

def next(_no_edit):
    for motion in cur_agenda():
        current = meta('current')
        if current.exists():
            current.unlink()
        start(_no_edit, motion)
    print("agenda done")

tail_re = re.compile(r'-[0-9]+(\.[0-9]+)*$')

def tail(motion):
    m = tail_re.search(str(motion))
    if m is None:
        return None
    return m.group()

def dot_tail(motion):
    m = tail_re.search(str(motion))
    if m is None:
        return None
    return m.group(1)

section_re = re.compile(r'^(-{3,})$', re.MULTILINE)

def sections(motion):
    data = read(motion)
    print("sections", section_re.search(data))
    return section_re.split(data)

#s/~~\(~\{0,1\}[^~]\)*~~//g
del_re = re.compile(r'~~(?:~?[^~]+)*~~')

#s/\^\^\(\(\^\{0,1\}[^\^]\)*\)\^\^/\1/g
ins_re = re.compile(r'\^\^(\^?[^\^]+)*\^\^')

def pass_block(text):
    print("pass_block", text)
    parts = del_re.split(text)
    print("del parts", parts)
    no_del = ''.join(parts)
    print("no_del", no_del)
    parts = ins_re.split(no_del)
    print("ins parts", parts)
    ans = ''.join(parts)
    print("ans", ans)
    return ans

def pass_(_no_edit, _dry_run):
    motion = get_current()
    print("pass", str(motion))
    check_open(motion)
    hyphen_count = str(motion).count('-')
    if hyphen_count:
        t = tail(motion)
        assert t is not None and t[0] == '-'
        dot = Path(str(motion)[:-len(t)] + '.' + t[1:])
        print("pass: got amendment, creating", dot)
        if dot.exists():
            print(f"{str(motion)} already passed", file=sys.stderr)
            sys.exit(1)
        if hyphen_count == 1:
            secs = sections(motion)
            print("pass: primary amendment")
            print("secs", secs)
            assert len(secs) == 3
            with dot.open('wt') as f:
                f.write(pass_block(secs[0]))
        else:
            assert hyphen_count == 2
            secs = sections(motion)
            print("pass: secondary amendment")
            print("secs", secs)
            assert len(secs) == 5
            with dot.open('wt') as f:
                f.write(secs[0])
                f.write(secs[1])   # hyphens
                f.write(pass_block(secs[2]))
        print("pass created", str(dot))
        if not _dry_run:
            #append(motion, 'passed')
            start(_no_edit, dot)
    else:
        print("pass: got motion")
        append(motion, 'passed')
        #FIX: next(_no_edit)

def fail(_no_edit):
    motion = get_current()
    print("fail", str(motion))
    check_open(motion)
    append(motion, 'failed')
    last_hyphen = str(motion).rfind('-')
    if last_hyphen >= 0:
        print("fail: got amendment")
        start(_no_edit, str(motion)[: last_hyphen])
    else:
        print("fail: got motion")
        #FIX: next(_no_edit)

def amend(_no_edit, _dry_run):
    motion = str(get_current())
    dot = motion.find('.')
    if dot >= 0:
        motion = motion[:dot]  # strip .X
    print("amend", motion)
    check_open(motion)
    hyphen_count = motion.count('-')
    if hyphen_count > 1:
        print(f"ERROR: amend {motion}, can't amend a secondary amendment", file=sys.stderr)
        sys.exit(1)
    if hyphen_count == 1:
        kind = 'amendment'
    else:
        kind = 'motion'
    history = motion_history(motion)
    last_motion = history[-1]
    dot = dot_tail(last_motion)
    if dot is not None:
        dot = dot[1:]
        dot2 = dot.find('.')
        if dot2 >= 0:
            dot = dot[: dot2]  # strip second dot
        next_num = int(dot) + 1
    else:
        next_num = 1
    new_file = Path(motion + f"-{next_num}")
    with new_file.open('wt') as f:
        with last_motion.open() as old_f:
            f.write(old_f.read())
        print("-------------------", file=f)
        print(f"amend the {kind} by ", file=f)
    print("amend created", str(new_file))
    if not _dry_run:
        start(_no_edit, new_file)

def new(_no_edit, _dry_run):
    # filenames are: newN
    last_num = max([int(str(name)[3:]) for name in Motiondir.glob('new*')], default=0)
    new_file = Path(f"new{last_num + 1}")
    print("new", str(new_file))
    if not _dry_run:
        start(_no_edit, new_file)

def commands():
    def get_args(fn):
        ans = []
        for arg, kind in getargs(fn):
            if kind == 'option':
                ans.append(f" [{arg[1:3]}|{arg}]")
            elif kind == 'required':
                ans.append(' ' + arg)
            else:
                ans.append(f" [{arg}]")
        return ''.join(ans)
    for name, fn in sorted(Commands.items()):
        print(f"{name}{get_args(fn)}")
        doc = inspect.getdoc(fn)
        if doc is not None:
            print(doc)
        print()

Commands = dict(
    current=current,
    agenda=agenda,
    passed=passed,
    failed=failed,
    start=start,
    restart=restart,
    next=next,
    pass_=pass_,
    fail=fail,
    amend=amend,
    new=new,
    commands=commands,
)

def getargs(fn):
    r'''Yields arg, kind.

    Where kind is 'option', 'required', or a default value

    If arg starts with '_', all '_' have been replaced with '-', leaving the initial '-'.
    '''
    argspec = inspect.getfullargspec(fn)
    fn_args = argspec.args
    fn_defaults = argspec.defaults or ()
    #print("fn_args", fn_args, "fn_defaults", fn_defaults)
    num_no_defaults = len(fn_args) - len(fn_defaults)
    arg_translate = {}
    for arg in fn_args[: num_no_defaults]:
        #print("adding arg", arg)
        if arg[0] == '_':
            yield '-' + arg.replace('_', '-'), 'option'
            #parser.add_argument(arg.replace('_', '-'), '-' + arg[1],
            #                    default=False, action='store_true')
            #arg_translate[arg[1:]] = arg
        else:
            yield arg, 'required'
            #parser.add_argument(arg)
    for arg, default in zip(fn_args[num_no_defaults:], fn_defaults):
        #print("adding arg", arg, "default", default)
        yield arg, default
        #parser.add_argument(arg, nargs='?', default=default)

if __name__ == "__main__":
    import argparse
    import inspect

    parser = argparse.ArgumentParser()

    name = Path(sys.argv[0]).name
    if name in ('pass',):
        name = name + '_'

    fn = Commands[name]
    for arg, kind in getargs(fn):
        if kind == 'option':
            parser.add_argument(arg, arg[1:3], default=False, action='store_true')
            arg_translate[arg[2:]] = arg[1:].replace('-', '_')
        elif kind == 'required':
            parser.add_argument(arg)
        else:
            parser.add_argument(arg, nargs='?', default=default)

    args = parser.parse_args()
    #print("args", args)

    arg_dict = {arg_translate.get(name, name): value for name, value in vars(args).items()}
    #print("arg_dict", arg_dict)
    fn(**arg_dict)
